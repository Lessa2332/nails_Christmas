<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üéÉ –ú–∞–Ω—ñ–∫—é—Ä –Ω–∞ –ì–µ–ª–ª–æ–≤—ñ–Ω!</title>
  <!-- –í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è favicon: data URL –∑ –µ–º–æ–¥–∑—ñ, —â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ 404 -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÉ</text></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }
    body {
      background: #0f0c29;
      background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
      overflow: hidden;
      font-family: 'Arial', 'Comic Sans MS', cursive, sans-serif;
      color: white;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain; /* –í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è: contain –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –æ–±—Ä—ñ–∑–∞–Ω–Ω—è */
    }
    #video {
      z-index: 5;
      background: black; /* –í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è: —á–æ—Ä–Ω–∏–π —Ñ–æ–Ω, —è–∫—â–æ –≤—ñ–¥–µ–æ –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏–ª–æ—Å—å */
    }
    #canvas {
      z-index: 10;
      background: transparent;
    }

    /* –ö–Ω–æ–ø–∫–∞ –º–æ–≤–∏ */
    #langBtn {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(5px);
      border: 2px solid white;
      color: white;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      font-weight: bold;
      transition: transform 0.2s;
    }
    #langBtn:hover {
      transform: scale(1.1);
    }

    /* –ó–≤—É–∫–æ–≤–∞ –∫–Ω–æ–ø–∫–∞ */
    #soundBtn {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(5px);
      border: 2px solid white;
      color: white;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: transform 0.2s;
    }
    #soundBtn:hover {
      transform: scale(1.1);
    }

    /* –ö–Ω–æ–ø–∫–∏ —Ä–µ–∂–∏–º—É */
    #modeControls {
      position: fixed;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
    }
    .mode-btn {
      padding: 8px 16px;
      border-radius: 20px;
      background: #ff6b6b;
      color: white;
      border: none;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: transform 0.2s;
    }
    .mode-btn:hover {
      transform: scale(1.05);
    }
    .mode-btn.active {
      background: #ff4757;
      animation: pulse 1.5s infinite;
    }

    /* –î–∏–∑–∞–π–Ω–∏ –∑ –ø—Ä–æ–∫—Ä—É—Ç–∫–æ—é */
    #designPicker {
      position: fixed;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: flex;
      gap: 14px;
      z-index: 100;
      overflow-x: auto;
      white-space: nowrap;
      padding: 0 20px;
      box-sizing: border-box;
      scrollbar-width: thin;
      scrollbar-color: #ff4757 transparent;
    }
    .design-btn {
      width: 64px;
      height: 64px;
      border-radius: 18px;
      border: 3px solid white;
      box-shadow: 0 4px 10px rgba(0,0,0,0.4);
      background: white;
      cursor: pointer;
      transition: transform 0.2s;
      flex-shrink: 0;
    }
    .design-btn:hover, .design-btn.selected {
      transform: scale(1.1);
      box-shadow: 0 0 0 4px gold;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0.7); }
      70% { box-shadow: 0 0 0 12px rgba(255, 71, 87, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0); }
    }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: orange;
      font-size: 20px;
      text-align: center;
      padding: 20px;
    }
    #loading p {
      margin-top: 20px;
      color: white;
      font-size: 16px;
    }

    #errorRetry {
      margin-top: 20px;
      padding: 10px 20px;
      background: #ff4757;
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      border-radius: 10px;
    }

    #cameraIndicator, #handIndicator {
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: lime;
      z-index: 100;
      display: none;
    }
    #handIndicator {
      top: 100px;
      color: white;
    }
  </style>
</head>
<body>
  <div id="loading">
    üéÉ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ì–µ–ª–ª–æ–≤—ñ–Ω—Å—å–∫–æ–≥–æ –º–∞–Ω—ñ–∫—é—Ä—É...
    <p>–ù–∞–¥–∞–π—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏, –∫–æ–ª–∏ –∑'—è–≤–∏—Ç—å—Å—è –∑–∞–ø–∏—Ç</p>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="langBtn" aria-label="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç–∏ –º–æ–≤—É">UK</div>
  <div id="soundBtn" aria-label="–£–≤—ñ–º–∫–Ω—É—Ç–∏/–≤–∏–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫">üîä</div>

  <div id="modeControls">
    <button class="mode-btn active" id="applyAllBtn" aria-label="–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –¥–æ –≤—Å—ñ—Ö –ø–∞–ª—å—Ü—ñ–≤">üíÖ –£—Å—ñ –ø–∞–ª—å—Ü—ñ</button>
    <button class="mode-btn" id="selectFingerBtn" aria-label="–û–±—Ä–∞—Ç–∏ –ø–∞–ª–µ—Ü—å">üëÜ –û–±—Ä–∞—Ç–∏ –ø–∞–ª–µ—Ü—å</button>
  </div>

  <div id="designPicker"></div>
  <div id="cameraIndicator">üìπ –ó–∞–¥–Ω—è –∫–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞</div>
  <div id="handIndicator">‚úã –†—É–∫–∞ –Ω–µ –≤–∏—è–≤–ª–µ–Ω–∞</div>

  <script type="module">
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    const translations = {
      en: {
        title: "üéÉ Halloween Nail Try-On!",
        loading: "üéÉ Loading Halloween Nail Try-On...",
        cameraPrompt: "Please allow camera access when prompted",
        allFingers: "üíÖ All Fingers",
        pickFinger: "üëÜ Pick Finger",
        cameraError: "‚ùå Could not access camera.<br>Try Chrome or Safari.",
        arError: "‚ùå AR failed to load.<br>Refresh the page.",
        retry: "Retry",
        cameraIndicator: "üìπ Camera Active",
        rearCamera: "üìπ Rear Camera Active",
        frontCamera: "üìπ Front Camera Active",
        handNotDetected: "‚úã Hand not detected"
      },
      uk: {
        title: "üéÉ –ú–∞–Ω—ñ–∫—é—Ä –Ω–∞ –ì–µ–ª–ª–æ–≤—ñ–Ω!",
        loading: "üéÉ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ì–µ–ª–ª–æ–≤—ñ–Ω—Å—å–∫–æ–≥–æ –º–∞–Ω—ñ–∫—é—Ä—É...",
        cameraPrompt: "–ù–∞–¥–∞–π—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏, –∫–æ–ª–∏ –∑'—è–≤–∏—Ç—å—Å—è –∑–∞–ø–∏—Ç",
        allFingers: "üíÖ –£—Å—ñ –ø–∞–ª—å—Ü—ñ",
        pickFinger: "üëÜ –û–±—Ä–∞—Ç–∏ –ø–∞–ª–µ—Ü—å",
        cameraError: "‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏.<br>–°–ø—Ä–æ–±—É–π—Ç–µ —É Chrome –∞–±–æ Safari.",
        arError: "‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è AR.<br>–°–ø—Ä–æ–±—É–π—Ç–µ –æ–Ω–æ–≤–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É.",
        retry: "–ü–æ–≤—Ç–æ—Ä–∏—Ç–∏",
        cameraIndicator: "üìπ –ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞",
        rearCamera: "üìπ –ó–∞–¥–Ω—è –∫–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞",
        frontCamera: "üìπ –ü–µ—Ä–µ–¥–Ω—è –∫–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞",
        handNotDetected: "‚úã –†—É–∫–∞ –Ω–µ –≤–∏—è–≤–ª–µ–Ω–∞"
      }
    };

    let currentLang = localStorage.getItem('lang') || 'uk';
    if (!['en', 'uk'].includes(currentLang)) currentLang = 'uk';
    document.documentElement.lang = currentLang;
    document.title = translations[currentLang].title;

    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const loading = document.getElementById("loading");
    const langBtn = document.getElementById("langBtn");
    const soundBtn = document.getElementById("soundBtn");
    const applyAllBtn = document.getElementById("applyAllBtn");
    const selectFingerBtn = document.getElementById("selectFingerBtn");
    const designPicker = document.getElementById("designPicker");
    const cameraIndicator = document.getElementById("cameraIndicator");
    const handIndicator = document.getElementById("handIndicator");

    function updateTexts(isRearCamera = true) {
      document.title = translations[currentLang].title;
      langBtn.textContent = currentLang.toUpperCase();
      langBtn.setAttribute('aria-label', currentLang === 'en' ? '–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç–∏ –Ω–∞ —É–∫—Ä–∞—ó–Ω—Å—å–∫—É' : 'Switch to English');
      
      loading.innerHTML = `
        üéÉ ${translations[currentLang].loading}
        <p>${translations[currentLang].cameraPrompt}</p>
      `;
      
      applyAllBtn.textContent = translations[currentLang].allFingers;
      selectFingerBtn.textContent = translations[currentLang].pickFinger;
      cameraIndicator.textContent = isRearCamera ? translations[currentLang].rearCamera : translations[currentLang].frontCamera;
      handIndicator.textContent = translations[currentLang].handNotDetected;
    }

    langBtn.onclick = () => {
      currentLang = currentLang === 'en' ? 'uk' : 'en';
      localStorage.setItem('lang', currentLang);
      document.documentElement.lang = currentLang;
      updateTexts(video.srcObject?.getVideoTracks()[0]?.getCapabilities().facingMode === 'environment');
    };

    const DESIGNS = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"];
    let currentDesign = "1";
    let nailImages = {};
    let isApplyAll = true;
    let selectedFingerIndex = -1;
    let isMuted = false;
    let bgAudio, clickAudio;
    let lastLandmarks = null;
    let smoothedLandmarks = null;
    const SMOOTHING_FACTOR = 0.7; // –í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è: –∑–±—ñ–ª—å—à–µ–Ω–æ –¥–ª—è –∫—Ä–∞—â–æ—ó —Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ
    let needsRedraw = true;
    let isRearCamera = true; // –ó–º—ñ–Ω–Ω–∞ –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Ç–∏–ø—É –∫–∞–º–µ—Ä–∏

    function initAudio() {
      bgAudio = new Audio("audio/bg-music.mp3");
      clickAudio = new Audio("audio/click.mp3");
      bgAudio.loop = true;
      bgAudio.volume = 0.3;
      clickAudio.volume = 0.6;
      if (!isMuted) bgAudio.play().catch(e => console.log("Audio autoplay blocked:", e));

      document.addEventListener('visibilitychange', () => {
        if (document.hidden && !isMuted) {
          bgAudio.pause();
        } else if (!document.hidden && !isMuted) {
          bgAudio.play().catch(() => {});
        }
      });
    }

    async function loadDesigns() {
      const promises = DESIGNS.map(name => new Promise((resolve, reject) => {
        const img = new Image();
        img.src = `nails/halloween/${name}.png`;
        img.onload = () => resolve({ name, img });
        img.onerror = () => reject(new Error(`Failed to load image: nails/halloween/${name}.png`));
      }));
      try {
        const loaded = await Promise.all(promises);
        nailImages = Object.fromEntries(loaded.map(({ name, img }) => [name, img]));
      } catch (e) {
        console.error(e);
        loading.innerHTML = `${translations[currentLang].arError}<br><button id="errorRetry">${translations[currentLang].retry}</button>`;
        document.getElementById('errorRetry').onclick = () => location.reload();
        throw e;
      }
    }

    function buildDesignUI() {
      designPicker.innerHTML = "";
      DESIGNS.forEach(name => {
        const btn = document.createElement("img");
        btn.src = `nails/halloween/${name}.png`;
        btn.className = "design-btn";
        btn.alt = `–î–∏–∑–∞–π–Ω –Ω—ñ–≥—Ç—ñ–≤ ${name}`;
        if (name === currentDesign) btn.classList.add("selected");
        btn.onclick = () => {
          currentDesign = name;
          document.querySelectorAll(".design-btn").forEach(b => b.classList.remove("selected"));
          btn.classList.add("selected");
          needsRedraw = true;
          if (!isMuted) {
            clickAudio.currentTime = 0;
            clickAudio.play().catch(() => {});
          }
        };
        designPicker.appendChild(btn);
      });
    }

    applyAllBtn.onclick = () => {
      isApplyAll = true;
      selectedFingerIndex = -1;
      applyAllBtn.classList.add("active");
      selectFingerBtn.classList.remove("active");
      needsRedraw = true;
    };
    
    selectFingerBtn.onclick = () => {
      isApplyAll = false;
      applyAllBtn.classList.remove("active");
      selectFingerBtn.classList.add("active");
      needsRedraw = true;
    };

    soundBtn.onclick = () => {
      isMuted = !isMuted;
      soundBtn.textContent = isMuted ? "üîá" : "üéµ";
      soundBtn.setAttribute('aria-label', isMuted ? '–£–≤—ñ–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫' : '–í–∏–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫');
      if (isMuted) {
        bgAudio.pause();
      } else {
        bgAudio.play().catch(() => {});
      }
    };

    async function setupCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { 
            facingMode: "environment",
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });
        video.srcObject = stream;
        cameraIndicator.style.display = 'block';
        isRearCamera = stream.getVideoTracks()[0].getCapabilities().facingMode === 'environment';
        updateTexts(isRearCamera);
        return new Promise(resolve => {
          video.onloadedmetadata = () => {
            video.play();
            resolve();
          };
        });
      } catch (e) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { 
              facingMode: "user",
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          });
          video.srcObject = stream;
          cameraIndicator.style.display = 'block';
          isRearCamera = false;
          updateTexts(false);
          return new Promise(resolve => {
            video.onloadedmetadata = () => {
              video.play();
              resolve();
            };
          });
        } catch (fallbackError) {
          loading.innerHTML = `${translations[currentLang].cameraError}<br><button id="errorRetry">${translations[currentLang].retry}</button>`;
          document.getElementById('errorRetry').onclick = setupCamera;
          console.error("Camera error:", fallbackError);
          throw fallbackError;
        }
      }
    }

    function smoothLandmarks(newLandmarks) {
      if (!smoothedLandmarks) {
        smoothedLandmarks = newLandmarks.map(lm => ({ x: lm.x, y: lm.y, z: lm.z }));
        return smoothedLandmarks;
      }
      for (let i = 0; i < newLandmarks.length; i++) {
        smoothedLandmarks[i].x = smoothedLandmarks[i].x * (1 - SMOOTHING_FACTOR) + newLandmarks[i].x * SMOOTHING_FACTOR;
        smoothedLandmarks[i].y = smoothedLandmarks[i].y * (1 - SMOOTHING_FACTOR) + newLandmarks[i].y * SMOOTHING_FACTOR;
        smoothedLandmarks[i].z = smoothedLandmarks[i].z * (1 - SMOOTHING_FACTOR) + newLandmarks[i].z * SMOOTHING_FACTOR;
      }
      return smoothedLandmarks;
    }

    function getClosestFinger(touchX, touchY, landmarks) {
      const fingerTips = [4, 8, 12, 16, 20];
      let minDist = Infinity;
      let closestIndex = -1;
      
      for (let i = 0; i < fingerTips.length; i++) {
        const lm = landmarks[fingerTips[i]];
        const x = lm.x * canvas.width;
        const y = lm.y * canvas.height;
        const dist = Math.hypot(touchX - x, touchY - y);
        
        if (dist < minDist && dist < canvas.width * 0.1) {
          minDist = dist;
          closestIndex = i;
        }
      }
      return closestIndex;
    }

    canvas.addEventListener("touchstart", e => {
      if (isApplyAll || !lastLandmarks) return;
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      selectedFingerIndex = getClosestFinger(x, y, lastLandmarks);
      needsRedraw = true;
    });

    function calculateNailSize(landmarks, fingerIndex) {
      const fingerTips = [4, 8, 12, 16, 20];
      const fingerBases = [1, 5, 9, 13, 17];
      const tip = landmarks[fingerTips[fingerIndex]];
      const base = landmarks[fingerBases[fingerIndex]];
      const dist = Math.hypot((tip.x - base.x) * canvas.width, (tip.y - base.y) * canvas.height);
      return Math.max(30, dist * 0.6); // –í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è: –∑–º–µ–Ω—à–µ–Ω–æ —Ä–æ–∑–º—ñ—Ä –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –Ω–∞–∫–ª–∞–¥–∞–Ω–Ω—è
    }

    function calculateNailAngle(landmarks, fingerIndex) {
      const fingerTips = [4, 8, 12, 16, 20];
      const fingerBases = [1, 5, 9, 13, 17];
      const tip = landmarks[fingerTips[fingerIndex]];
      const base = landmarks[fingerBases[fingerIndex]];
      return Math.atan2(tip.y - base.y, tip.x - base.x) * 180 / Math.PI;
    }

    function renderAR(landmarks) {
      if (!needsRedraw) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();

      // –í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è: –¥–∑–µ—Ä–∫–∞–ª—å–Ω–µ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Ç—ñ–ª—å–∫–∏ –¥–ª—è –ø–µ—Ä–µ–¥–Ω—å–æ—ó –∫–∞–º–µ—Ä–∏
      if (!isRearCamera) {
        ctx.scale(-1, 1);
        ctx.translate(-canvas.width, 0);
      }

      const fingerTips = [4, 8, 12, 16, 20];
      const img = nailImages[currentDesign];
      
      if (!img || !img.complete) return;

      for (let i = 0; i < fingerTips.length; i++) {
        if (!isApplyAll && i !== selectedFingerIndex) continue;
        
        const lm = landmarks[fingerTips[i]];
        const x = lm.x * canvas.width;
        const y = lm.y * canvas.height;

        if (!isApplyAll && i === selectedFingerIndex) {
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, 2 * Math.PI);
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 3;
          ctx.stroke();
        }

        const size = calculateNailSize(landmarks, i);
        const angle = calculateNailAngle(landmarks, i);
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle * Math.PI / 180); // –í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è: —Å–∫–æ—Ä–∏–≥–æ–≤–∞–Ω–æ –∫—É—Ç (–±–µ–∑ +90)
        ctx.drawImage(img, -size / 2, -size * 0.6, size, size / 2); // –í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è: –æ—Ñ—Å–µ—Ç y –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –ø–æ–∑–∏—Ü—ñ–æ–Ω—É–≤–∞–Ω–Ω—è –Ω–∞ –Ω—ñ–≥—Ç—è—Ö
        ctx.restore();
      }

      ctx.restore();
      needsRedraw = false;
    }

    let handLandmarker;
    async function init() {
      try {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1
        });

        await setupCamera();
        
        function updateCanvasSize() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          video.style.width = '100%';
          video.style.height = '100%';
          needsRedraw = true;
        }

        let resizeTimeout;
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(updateCanvasSize, 100);
        });
        updateCanvasSize();

        await loadDesigns();
        buildDesignUI();
        initAudio();
        updateTexts();

        loading.style.display = "none";

        let lastVideoTime = -1;
        
        const predict = () => {
          if (handLandmarker && video.readyState >= 2) {
            const currentTime = performance.now();
            
            if (currentTime - lastVideoTime > 100) {
              const predictions = handLandmarker.detectForVideo(video, currentTime);
              
              if (predictions.landmarks && predictions.landmarks.length > 0) {
                lastLandmarks = smoothLandmarks(predictions.landmarks[0]);
                handIndicator.style.display = 'none';
                renderAR(lastLandmarks);
              } else {
                handIndicator.style.display = 'block';
                if (needsRedraw) {
                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  needsRedraw = false;
                }
              }
              
              lastVideoTime = currentTime;
            }
          }
          requestAnimationFrame(predict);
        };
        
        predict();

        window.addEventListener("beforeunload", () => {
          if (video.srcObject) {
            video.srcObject.getTracks().forEach(track => track.stop());
          }
          if (handLandmarker) {
            handLandmarker.close();
          }
          cameraIndicator.style.display = 'none';
        });
      } catch (e) {
        console.error("Initialization error:", e);
        loading.innerHTML = `${translations[currentLang].arError}<br><button id="errorRetry">${translations[currentLang].retry}</button>`;
        document.getElementById('errorRetry').onclick = () => location.reload();
      }
    }

    window.addEventListener("load", init);
  </script>
</body>
</html>
