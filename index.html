<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Christmas Nails AR</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='80'>Christmas</text></svg>">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#8B0000">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; touch-action: manipulation; }
    body {
      background: linear-gradient(135deg, #8B0000, #228B22, #FFD700);
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      color: white;
    }
    #video, #canvas, #confettiCanvas {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;
    }
    #video { z-index: 1; display: none; }
    #canvas { z-index: 2; display: none; }
    #confettiCanvas { z-index: 60; pointer-events: none; }

    .control-btn {
      position: fixed; min-width: 56px; height: 56px; border-radius: 50%;
      background: rgba(255, 255, 255, 0.25); backdrop-filter: blur(20px);
      border: 2px solid rgba(255, 255, 255, 0.5); color: white;
      font-size: 18px; display: flex; align-items: center; justify-content: center;
      cursor: pointer; z-index: 100; transition: all 0.3s ease;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    .control-btn:hover { transform: scale(1.15); background: rgba(255, 255, 255, 0.35); }

    #uploadBtn { top: 20px; left: 20px; }
    #langBtn { top: 20px; right: 20px; font-weight: bold; }
    #soundBtn { top: 84px; left: 20px; }
    #authorBtn {
      top: 84px; right: 20px; background: linear-gradient(135deg, #FFD700, #FFA500);
      border: 3px solid #FFF; color: #8B0000; font-weight: bold;
      box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6), 0 0 0 4px #FFF;
      animation: pulse-glow 2s infinite;
    }
    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6), 0 0 0 4px #FFF; }
      50% { box-shadow: 0 8px 30px rgba(255, 215, 0, 0.8), 0 0 0 6px #FFF; }
    }

    #modeControls {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 10px; z-index: 100;
      background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(20px);
      padding: 6px 12px; border-radius: 25px;
      border: 1px solid rgba(255, 255, 255, 0.4);
    }
    .mode-btn {
      padding: 8px 16px; border-radius: 20px;
      background: linear-gradient(135deg, #FFD700, #FFA500);
      color: #8B0000; border: none; font-weight: 600;
      font-size: 13px; cursor: pointer; transition: all 0.3s ease;
    }
    .mode-btn.active { background: linear-gradient(135deg, #FFF, #FFD700); color: #8B0000; }

    #designPicker {
      position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 12px; z-index: 100;
      background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(20px);
      padding: 15px; border-radius: 25px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      max-width: 90vw; overflow-x: auto;
      scrollbar-width: none;
    }
    .design-btn {
      width: 60px; height: 90px; border-radius: 16px;
      border: 3px solid rgba(255, 255, 255, 0.4);
      object-fit: contain; background: transparent;
      cursor: pointer; transition: all 0.3s ease; flex-shrink: 0;
    }
    .design-btn.selected {
      border-color: #FFD700; box-shadow: 0 0 0 3px #FFD700; transform: scale(1.15);
    }

    #uploadModal {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.98); backdrop-filter: blur(30px);
      padding: 25px; border-radius: 24px; border: 2px solid #FFD700;
      z-index: 1000; display: none; color: white; text-align: center;
      width: 90%; max-width: 380px; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
    }
    #uploadModal.show { display: block; animation: modalIn 0.4s ease; }
    #imageUpload {
      margin: 15px 0; padding: 14px; border: 2px dashed #FFD700;
      border-radius: 14px; background: rgba(40, 40, 40, 0.7);
      color: white; width: 100%; cursor: pointer; font-size: 14px;
    }
    .modal-btn {
      padding: 12px 24px; margin: 8px; border: none; border-radius: 20px;
      font-weight: 600; cursor: pointer; transition: all 0.3s ease;
    }
    #saveDesign { background: linear-gradient(135deg, #FFD700, #FFA500); color: #8B0000; }
    #closeModal { background: rgba(50, 50, 50, 0.9); color: #FFD700; border: 1.5px solid #FFD700; }

    #loading {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(135deg, #8B0000, #228B22);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 1000; color: #FFD700; font-size: 24px; text-align: center; padding: 20px; gap: 20px;
    }
    .loader {
      width: 60px; height: 60px; border: 4px solid rgba(255, 215, 0, 0.3);
      border-top: 4px solid #FFD700; border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .indicator {
      position: fixed; left: 50%; transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(10px);
      color: white; padding: 8px 16px; border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.3); display: none;
      align-items: center; gap: 8px; z-index: 99; font-size: 14px;
    }
    #handIndicator { top: 160px; }
    .indicator.show { display: flex; animation: slideDown 0.3s ease; }

    @keyframes spin { to { transform: rotate(360deg); } }
    @keyframes modalIn { from { opacity: 0; transform: translate(-50%, -48%); } to { opacity: 1; transform: translate(-50%, -50%); } }
    @keyframes slideDown { from { opacity: 0; transform: translateX(-50%) translateY(-10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }

    @media (max-width: 768px) {
      .control-btn { width: 48px; height: 48px; font-size: 16px; }
      #authorBtn { top: 78px; }
      .design-btn { width: 50px; height: 75px; }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loader"></div>
    <div>Різдвяний манікюр завантажується...</div>
    <p>Дозвольте доступ до камери</p>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>
  <canvas id="confettiCanvas"></canvas>

  <button id="uploadBtn" class="control-btn">Upload</button>
  <button id="langBtn" class="control-btn">UK</button>
  <button id="soundBtn" class="control-btn">Sound</button>
  <a href="https://smartlessa.etsy.com" target="_blank" id="authorBtn" class="control-btn">Author</a>

  <div id="modeControls">
    <button class="mode-btn active" id="applyAllBtn">Усі пальці</button>
    <button class="mode-btn" id="selectFingerBtn">Обрати</button>
  </div>

  <div id="designPicker"></div>

  <div id="uploadModal">
    <h3 style="color:#FFD700;">Завантаж свій дизайн</h3>
    <p style="font-size:13px; margin:12px 0; color:#ccc;">Найкраще — PNG з прозорим фоном</p>
    <input type="file" id="imageUpload" accept="image/*">
    <div style="margin-top:20px;">
      <button id="saveDesign" class="modal-btn">Зберегти</button>
      <button id="closeModal" class="modal-btn">Скасувати</button>
    </div>
  </div>

  <div id="handIndicator" class="indicator">
    <span>Christmas Hand</span><span>Покажи руку</span>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.158.0/build/three.module.js" } }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    const CONFIG = {
      SMOOTHING_FACTOR: 0.7,
      HAND_NOT_DETECTED_THRESHOLD: 10,
      NAIL_SCALE_FACTORS: { thumb: 0.42, index: 0.52, middle: 0.54, ring: 0.52, pinky: 0.40 },
      NAIL_ASPECT_RATIOS: { thumb: 0.78, index: 0.72, middle: 0.70, ring: 0.74, pinky: 0.80 },
      NAIL_OFFSETS: {
        thumb: { x: -0.01, y: -0.02 },
        index: { x: 0, y: -0.02 },
        middle: { x: 0, y: -0.025 },
        ring: { x: 0, y: -0.02 },
        pinky: { x: 0.005, y: -0.015 }
      },
      MIN_SIZE: 25, MAX_SIZE: 85,
      WRIST_DISTANCE_REF: 0.1, SCALE_SENSITIVITY: 1.8,
      MAX_SCALE_FACTOR: 2.0, MIN_SCALE_FACTOR: 0.6
    };

    const FINGER_INDICES = {
      thumb: { tip: 4, mcp: 2 }, index: { tip: 8, mcp: 5 },
      middle: { tip: 12, mcp: 9 }, ring: { tip: 16, mcp: 13 },
      pinky: { tip: 20, mcp: 17 }
    };
    const FINGER_KEYS = Object.keys(FINGER_INDICES);

    const state = {
      currentDesign: "red_oval",
      isApplyAll: true,
      selectedFingerIndex: -1,
      isMuted: false,
      lastLandmarks: null,
      smoothedLandmarks: null,
      handNotDetectedCount: 0,
      animationFrameId: null,
      currentHandSize: 1.0,
      customDesigns: [],
      isLeftHand: false
    };

    const el = {
      video: document.getElementById("video"),
      canvas: document.getElementById("canvas"),
      confettiCanvas: document.getElementById("confettiCanvas"),
      loading: document.getElementById("loading"),
      uploadBtn: document.getElementById("uploadBtn"),
      langBtn: document.getElementById("langBtn"),
      soundBtn: document.getElementById("soundBtn"),
      authorBtn: document.getElementById("authorBtn"),
      applyAllBtn: document.getElementById("applyAllBtn"),
      selectFingerBtn: document.getElementById("selectFingerBtn"),
      designPicker: document.getElementById("designPicker"),
      uploadModal: document.getElementById("uploadModal"),
      imageUpload: document.getElementById("imageUpload"),
      saveDesign: document.getElementById("saveDesign"),
      closeModal: document.getElementById("closeModal"),
      handIndicator: document.getElementById("handIndicator")
    };

    const nailTextures = {};
    let scene, camera, renderer, handLandmarker;
    const nails = {};
    const confettiCtx = el.confettiCanvas.getContext("2d");
    let confetti = [];

    // === Червоний овальний манікюр (готовий) ===
    function createRedOvalNail() {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 384;
      const ctx = canvas.getContext('2d');

      // Червоний градієнт
      const grad = ctx.createLinearGradient(0, 0, 0, 384);
      grad.addColorStop(0, '#DC143C');
      grad.addColorStop(1, '#B22222');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 256, 384);

      // Овальна форма
      ctx.globalCompositeOperation = 'destination-in';
      ctx.beginPath();
      ctx.ellipse(128, 192, 100, 150, 0, 0, Math.PI * 2);
      ctx.fill();

      // Блиск
      ctx.globalCompositeOperation = 'source-over';
      const shine = ctx.createLinearGradient(0, 100, 256, 100);
      shine.addColorStop(0, 'rgba(255,255,255,0.4)');
      shine.addColorStop(0.5, 'rgba(255,255,255,0)');
      shine.addColorStop(1, 'rgba(255,255,255,0.4)');
      ctx.fillStyle = shine;
      ctx.fillRect(0, 0, 256, 384);

      return new THREE.CanvasTexture(canvas);
    }

    // === Конфетті ===
    class ConfettiParticle {
      constructor(x, y) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = Math.random() * -15 - 5;
        this.size = Math.random() * 6 + 4;
        this.color = ['#FFD700', '#DC143C', '#228B22', '#FFF'][Math.floor(Math.random() * 4)];
        this.life = 1.0;
        this.gravity = 0.4;
      }
      update() { this.vy += this.gravity; this.x += this.vx; this.y += this.vy; this.life -= 0.015; }
      draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.translate(this.x, this.y);
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
        ctx.restore();
      }
    }

    // === Ініціалізація ===
    class ChristmasNailAR {
      async init() {
        this.setupEvents();
        await this.setupCamera();
        await this.initWebGL();
        await this.setupHandTracking();
        this.loadDefaultDesign();
        this.buildUI();
        this.hideLoading();
        this.startLoop();
      }

      setupEvents() {
        el.uploadBtn.onclick = () => el.uploadModal.classList.add('show');
        el.closeModal.onclick = () => { el.uploadModal.classList.remove('show'); el.imageUpload.value = ''; };
        el.saveDesign.onclick = () => this.uploadDesign();
        el.applyAllBtn.onclick = () => { state.isApplyAll = true; el.applyAllBtn.classList.add('active'); el.selectFingerBtn.classList.remove('active'); };
        el.selectFingerBtn.onclick = () => { state.isApplyAll = false; el.applyAllBtn.classList.remove('active'); el.selectFingerBtn.classList.add('active'); };
        el.canvas.onclick = (e) => this.handleClick(e);
      }

      loadDefaultDesign() {
        nailTextures["red_oval"] = createRedOvalNail();
        const btn = document.createElement('div');
        btn.className = 'design-btn selected';
        btn.style.background = 'linear-gradient(135deg, #DC143C, #B22222)';
        btn.style.borderRadius = '16px';
        btn.onclick = () => {
          state.currentDesign = "red_oval";
          document.querySelectorAll('.design-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
        };
        el.designPicker.appendChild(btn);
      }

      async uploadDesign() {
        const file = el.imageUpload.files[0];
        if (!file) return alert("Оберіть зображення");
        const img = new Image();
        img.src = URL.createObjectURL(file);
        await new Promise(r => img.onload = r);

        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 384;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, 256, 384);
        ctx.globalCompositeOperation = 'destination-in';
        ctx.beginPath();
        ctx.ellipse(128, 192, 100, 150, 0, 0, Math.PI * 2);
        ctx.fill();

        const texture = new THREE.CanvasTexture(canvas);
        const id = `custom_${Date.now()}`;
        nailTextures[id] = texture;
        state.currentDesign = id;

        const btn = document.createElement('img');
        btn.src = img.src; btn.className = 'design-btn selected';
        btn.onclick = () => {
          state.currentDesign = id;
          document.querySelectorAll('.design-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
        };
        el.designPicker.appendChild(btn);

        el.uploadModal.classList.remove('show');
        el.imageUpload.value = '';
        this.triggerConfetti();
      }

      triggerConfetti() {
        const rect = el.designPicker.getBoundingClientRect();
        for (let i = 0; i < 50; i++) {
          confetti.push(new ConfettiParticle(rect.left + rect.width / 2, rect.top + rect.height / 2));
        }
      }

      updateConfetti() {
        confetti = confetti.filter(p => p.life > 0);
        confetti.forEach(p => p.update());
        confettiCtx.clearRect(0, 0, el.confettiCanvas.width, el.confettiCanvas.height);
        confetti.forEach(p => p.draw(confettiCtx));
      }

      async setupCamera() {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }
        });
        el.video.srcObject = stream;
        await new Promise(r => el.video.onloadedmetadata = r);
        el.video.play();
      }

      async initWebGL() {
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(-innerWidth/2, innerWidth/2, innerHeight/2, -innerHeight/2, 0.1, 1000);
        camera.position.z = 10;
        renderer = new THREE.WebGLRenderer({ canvas: el.canvas, alpha: true, antialias: true });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight);

        const material = new THREE.ShaderMaterial({
          uniforms: { map: { value: null }, time: { value: 0 } },
          vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
          fragmentShader: `
            uniform sampler2D map; uniform float time;
            varying vec2 vUv;
            void main() {
              vec4 tex = texture2D(map, vUv);
              if (tex.a < 0.1) discard;
              float shine = pow(smoothstep(0.3, 0.7, vUv.y + sin(vUv.y * 8.0 - time) * 0.1), 2.0) * 0.5;
              gl_FragColor = vec4(tex.rgb + vec3(shine), tex.a);
            }
          `,
          transparent: true
        });

        FINGER_KEYS.forEach(key => {
          const geo = new THREE.PlaneGeometry(CONFIG.NAIL_ASPECT_RATIOS[key], 1);
          const mat = material.clone();
          const nail = new THREE.Mesh(geo, mat);
          nail.visible = false; nail.frustumCulled = false;
          nails[key] = nail; scene.add(nail);
        });
      }

      async setupHandTracking() {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
          runningMode: "VIDEO", numHands: 1
        });
      }

      startLoop() {
        const loop = () => {
          this.detectHands();
          this.renderAR();
          this.updateConfetti();
          requestAnimationFrame(loop);
        };
        loop();
      }

      detectHands() {
        if (!handLandmarker || el.video.readyState < 2) return;
        const results = handLandmarker.detectForVideo(el.video, performance.now());
        if (results.landmarks?.length > 0) {
          state.handNotDetectedCount = 0;
          el.handIndicator.classList.remove('show');
          const lm = results.landmarks[0];
          state.lastLandmarks = this.smooth(lm);
        } else if (++state.handNotDetectedCount > 10) {
          el.handIndicator.classList.add('show');
          this.hideAll();
        }
      }

      smooth(newLm) {
        if (!state.smoothedLandmarks) state.smoothedLandmarks = newLm.map(p => ({...p}));
        state.smoothedLandmarks.forEach((s, i) => {
          s.x = s.x * (1 - 0.7) + newLm[i].x * 0.7;
          s.y = s.y * (1 - 0.7) + newLm[i].y * 0.7;
        });
        return state.smoothedLandmarks;
      }

      renderAR() {
        if (!state.lastLandmarks) return;
        FINGER_KEYS.forEach((key, i) => {
          if (!state.isApplyAll && i !== state.selectedFingerIndex) {
            nails[key].visible = false; return;
          }
          this.updateNail(key);
          nails[key].visible = true;
        });
        renderer.render(scene, camera);
      }

      updateNail(key) {
        const lm = state.lastLandmarks;
        const { tip, mcp } = FINGER_INDICES[key];
        const tipLm = lm[tip], mcpLm = lm[mcp];
        const x = tipLm.x * innerWidth, y = (1 - tipLm.y) * innerHeight;
        const len = Math.hypot((tipLm.x - mcpLm.x) * innerWidth, (tipLm.y - mcpLm.y) * innerHeight);
        let size = len * CONFIG.NAIL_SCALE_FACTORS[key] * state.currentHandSize;
        size = Math.max(25, Math.min(85, size));
        const angle = Math.atan2(tipLm.y - mcpLm.y, tipLm.x - mcpLm.x);

        const nail = nails[key];
        nail.position.set(x - innerWidth/2, y - innerHeight/2, 0);
        nail.scale.set(size * CONFIG.NAIL_ASPECT_RATIOS[key], size, 1);
        nail.rotation.z = angle;
        nail.material.uniforms.map.value = nailTextures[state.currentDesign];
        nail.material.uniforms.time.value = performance.now() * 0.001;
      }

      hideAll() { FINGER_KEYS.forEach(k => nails[k].visible = false); renderer.render(scene, camera); }

      handleClick(e) {
        if (state.isApplyAll || !state.lastLandmarks) return;
        const rect = el.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        let min = Infinity, idx = -1;
        FINGER_KEYS.forEach((k, i) => {
          const tip = state.lastLandmarks[FINGER_INDICES[k].tip];
          const dist = Math.hypot(x - tip.x * innerWidth, y - (1 - tip.y) * innerHeight);
          if (dist < min && dist < 100) { min = dist; idx = i; }
        });
        state.selectedFingerIndex = idx;
      }

      hideLoading() {
        el.loading.style.display = 'none';
        el.video.style.display = 'block';
        el.canvas.style.display = 'block';
      }
    }

    window.addEventListener('DOMContentLoaded', () => new ChristmasNailAR().init());
  </script>
</body>
</html>
